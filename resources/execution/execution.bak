package execution

import (
	"code.google.com/p/go.crypto/ssh"
	"errors"
	"fmt"
	"github.com/dancannon/gorethink"
	"github.com/gorilla/websocket"
	"github.com/martini-contrib/render"
	"io"
	"mussh/resources/command"
	"mussh/resources/server"
	"net/http"
	"strconv"
	"sync"
)

type Execution struct {
	Id        string      `gorethink:"id,omitempty" json:"id" form:"id"`
	Username  string      `json:"username" form:"username"`
	Password  string      `json:"-" form:"password"`
	GroupId   string      `json:"groupId" form:"groupId"`
	CommandId string      `json:"commandId" form:"commandId"`
	Results   []SshResult `json:"results"`
}

type SshResult struct {
	Server  server.Server `json:"server"`
	Output  string        `json:"output"`
	Success bool          `json:"success"`
}

func Post(session *gorethink.Session, r render.Render, exe Execution) {
	servers := getServers(session, exe.GroupId)
	cmd := getCommand(session, exe.CommandId)
	config := getConfig(exe)

	var results []SshResult
	resultChan := make(chan SshResult)
	var wg sync.WaitGroup
	for _, svr := range servers {
		wg.Add(1)
		go func(svr server.Server) {
			defer wg.Done()
			resultChan <- runCommand(svr, config, cmd)
		}(svr)
	}
	go func() {
		wg.Wait()
		close(resultChan)
	}()
	for result := range resultChan {
		results = append(results, result)
	}

	exe.Results = results
	r.JSON(http.StatusOK, exe)
}

func runCommand(svr server.Server, config *ssh.ClientConfig, cmd command.Command) <-chan SshResult {
	sshSession, err := createConnection(config, svr)
	if err != nil {
		return SshResult{svr, err.Error(), false}
	}
	defer sshSession.Close()

	script := cmd.Script
	if svr.BaseDir != "" {
		script = "cd " + svr.BaseDir + " && " + script
	}

	stdoutPipe, _ := sshSession.StdoutPipe()
	stderrPipe, _ := sshSession.StderrPipe()
	pipeChan := make(chan string)
	go readFromPipe(io.MultiReader(stdoutPipe, stderrPipe), pipeChan)

	err = sshSession.Start(script)
	if err != nClose() {
		return SshResult{svr, "Failed to run the command (Base Directory: " + svr.BaseDir + "): " +
			cmd.Script + "\n\n" + <-pipeChan, false}
	}

	return pipeChan, err
}

func readFromPipe(pipeReader io.Reader, pipeChan chan<- string) {
	buffer := make([]byte, 4096)
	for {
		n, err := pipeReader.Read(buffer)
		if err != nil {
			break
		}
		result := string(buffer[:n])
		fmt.Println(result)
		// pipeChan <- result
	}
}

func createConnection(config *ssh.ClientConfig, svr server.Server) (*ssh.Session, error) {
	var client *ssh.Client
	if svr.Tunnel != "" {
		tunnelClient, err := ssh.Dial("tcp", svr.Tunnel+":"+strconv.Itoa(svr.Port), config)
		if err != nil {
			return nil, errors.New("Failed to dial tunnel address: " + svr.Tunnel + "\n\n" + err.Error())
		}
		tunnelConnection, err := tunnelClient.Dial("tcp", svr.Addr+":"+strconv.Itoa(svr.Port))
		if err != nil {
			return nil, errors.New("Failed to dial server: " + svr.Addr + "\n\n" + err.Error())
		}
		c, chans, reqs, err := ssh.NewClientConn(tunnelConnection, svr.Addr, config)
		if err != nil {
			return nil, errors.New("Failed to establish SSH connection with server: " + svr.Addr + "\n\n" + err.Error())
		}

		client = ssh.NewClient(c, chans, reqs)
	} else {
		client2, err := ssh.Dial("tcp", svr.Addr+":"+strconv.Itoa(svr.Port), config)
		if err != nil {
			return nil, errors.New("Failed to establish SSH connection with server: " + svr.Addr + "\n\n" + err.Error())
		}
		client = client2
	}

	session, err := client.NewSession()
	if err != nil {
		return nil, errors.New("Failed to create SSH session for server: " + svr.Addr + "\n\n" + err.Error())
	}

	return session, nil
}

func getServers(session *gorethink.Session, groupId string) []server.Server {
	rows, _ := gorethink.Table("server").Filter(
		func(serverTerm gorethink.RqlTerm) gorethink.RqlTerm {
			return serverTerm.Field("GroupIds").Contains(groupId)
		}).Run(session)
	var servers []server.Server
	rows.ScanAll(&servers)
	return servers
}

func getCommand(session *gorethink.Session, commandId string) command.Command {
	row, _ := gorethink.Table("command").Get(commandId).RunRow(session)
	var command command.Command
	row.Scan(&command)
	return command
}

func getConfig(exe Execution) *ssh.ClientConfig {
	return &ssh.ClientConfig{
		User: exe.Username,
		Auth: []ssh.AuthMethod{
			ssh.Password(exe.Password),
		},
	}
}
